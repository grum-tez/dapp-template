archetype tidemark_fa2(owner : address, permits : address, minter : address) with metadata ""

/* OWNERSHIP TRANSFER ------------------------------------------------------- */

variable owner_candidate : option<address> = none
variable null_address: address = KT18amZmM5W7qDWVt2pH6uj7sCEd3kbzLrHT

entry declare_ownership(candidate : address) {
  no transfer
  called by owner
  effect {
    owner_candidate := some(candidate);
  }
}

entry claim_ownership() {
  no transfer
  require {
    ownership_r1: (owner_candidate ? the = caller : false) otherwise "INVALID_CALLER"
  }
  effect {
    owner := caller;
    owner_candidate := none
  }
}

/*  PAUSABLE ----------------------------------------------------------------- */

variable paused : bool = false

function is_not_paused() : bool {
  do_fail_if(paused, "CONTRACT_PAUSED");
  return true
}

entry pause() {
  no transfer
  called by owner
  require {
    pausable_r1: is_not_paused()
  }
  effect {
    paused := true
  }
}

entry unpause() {
  no transfer
  called by owner
  require {
    pausable_r2: paused otherwise "CONTRACT_NOT_PAUSED"
  }
  effect {
    paused := false
  }
}

/* METADATA ---------------------------------------------------------------- */

entry set_metadata(k: string, d : option<bytes>) {
  no transfer
  called by owner
  require { md_r1 : is_not_paused() }
  effect {
    metadata.update(k, d)
  }
}

/* TOKEN METADATA ------------------------------------------------------------ */

asset token_metadata to big_map {
  ftoken_metadata : nat;
  token_id        : nat;
  token_info      : map<string, bytes>;
}

entry set_token_metadata (tid : nat, tdata: map<string, bytes>) {
  no transfer
  called by owner
  require { tmd_r1: is_not_paused() }
  effect {
    token_metadata.add_update(tid, { token_id = tid; token_info = tdata });
  }
}

/* PERMITS ----------------------------------------------------------------- */

entry set_permits(p : address) {
  no transfer
  called by owner
  require { p_r1 : is_not_paused() }
  effect {
    permits := p
  }
}

/* ERRORS ----------------------------------------------------------------- */

constant FA2_INSUFFICIENT_BALANCE : string = "FA2_INSUFFICIENT_BALANCE"
constant FA2_INVALID_AMOUNT       : string = "FA2_INVALID_AMOUNT"
constant FA2_NOT_OPERATOR         : string = "FA2_NOT_OPERATOR"
constant FA2_NOT_OWNER            : string = "FA2_NOT_OWNER"
constant FA2_TOKEN_UNDEFINED      : string = "FA2_TOKEN_UNDEFINED"
constant SIGNER_NOT_FROM          : string = "SIGNER_NOT_FROM"

/* PARAMETERS ------------------------------------------------------------- */

record transfer_destination {
  to_dest           : address;
  token_id_dest     : nat;
  token_amount_dest : nat
} as ((%to_, (token_id, amount)))

record transfer_param {
  tp_from : address;
  tp_txs  : list<transfer_destination>;
} as ((%from_, %txs))

/* STORAGE ---------------------------------------------------------------- */

enum sale_cycle_state =
| tidemark_auction
| english_auction
| grace_period
| unclaimed

variable tidemark : tez = 0tz

asset ledger identified by l_token_id to big_map {
  l_token_id   : nat;
  l_token_creator : address;
  l_token_owner     : address;
  l_tidemark: tez = 0tz;
  l_creator_rate: rational;
  l_marketplace_rate: rational;
  l_minter_rate: rational;
  l_sale_cycle_state: sale_cycle_state = tidemark_auction;
  l_bid_count : nat = 0;
  //bid record inputs:
  l_bid: tez = 0tz;
  l_bidder: address = null_address;
  l_marketplace: address = null_address;
  l_tidemark_duration: duration = 1w;
  l_grace_period_duration: duration = 1d;

}

record bid_record {
  br_bid: tez;
  br_bidder: address;
  br_marketplace: address;
}

asset bid_history identified by bh_asset_id {
  bh_asset_id : nat;
  bh_token_id: nat;
  bh_bid_records: list<bid_record> = []

}

asset operator identified by oaddr otoken oowner to big_map {
  oaddr       : address;
  otoken      : nat;
  oowner      : address;
}

asset operator_for_all identified by fa_oaddr fa_oowner to big_map {
  fa_oaddr    : address;
  fa_oowner   : address;
}

/* FUNCTIONS --------------------------------------------------------------- */

function get_from(txs : list<transfer_param>) : option<address> {
  match txs with
  | hd::tl -> begin
    const %from = hd.tp_from;
    for tx in tl do
      do_require(%from = tx.tp_from, FA2_NOT_OPERATOR)
    done;
    return some(%from)
  end
  | [] -> return none
  end
}

function check_operator(txs : list<transfer_param>) : bool {
  var res = true;
  for tx in txs do
    const %from = tx.tp_from;
    const tds = tx.tp_txs;
    for td in tds do begin
      res &=
        if caller <> %from then
          (operator.contains((caller, td.token_id_dest, %from)) or
           operator_for_all.contains((caller, %from)))
        else
          true;
    end
    done
  done;
  return res
}

/* ENTRYPOINTS ------------------------------------------------------------- */

record operator_param {
  opp_owner    : address;
  opp_operator : address;
  opp_token_id : nat
} as ((owner, (operator, token_id)))

enum update_op =
| add_operator<operator_param>
| remove_operator<operator_param>

entry update_operators (upl : list<update_op>) {
  no transfer
  require { fa2_r1 : is_not_paused() }
  effect {
    for up in upl do
      match up with
      | add_operator(param) -> (* add *)
        do_require(param.opp_owner = caller , FA2_NOT_OWNER);
        operator.put({param.opp_operator; param.opp_token_id; param.opp_owner})
      | remove_operator(param) -> (* remove *)
        do_require(param.opp_owner = caller , FA2_NOT_OWNER);
        operator.remove((param.opp_operator, param.opp_token_id, param.opp_owner))
      end;
    done;
  }
}

enum update_for_all_op =
| add_for_all<address>
| remove_for_all<address>

entry update_operators_for_all (upl : list<update_for_all_op>) {
  no transfer
  require { fa2_r2 : is_not_paused() }
  effect {
    for up in upl do
      match up with
      | add_for_all(op) ->
          operator_for_all.put({ op; caller })
      | remove_for_all(op) ->
          operator_for_all.remove((op, caller))
      end;
    done;
  }
}

entry do_transfer(txs : list<transfer_param>) {
  no transfer
  called by self_address
  effect {
    for tx in txs do
      const %from = tx.tp_from;
      const tds   = tx.tp_txs;
      for td in tds do begin
        const tokenid = td.token_id_dest;
        const towner ?= ledger[tokenid]?.l_token_owner : FA2_TOKEN_UNDEFINED;
        if td.token_amount_dest > 0
        then begin
          do_require(towner = %from and td.token_amount_dest = 1, FA2_INSUFFICIENT_BALANCE);
          ledger.update(tokenid, { l_token_owner = td.to_dest })
        end
      end done
    done
  }
}

record gasless_param {
  transfer_params : list<transfer_param>;
  user_pk         : key;
  user_sig        : signature
}

function check_owner(addr : address, txs : list<transfer_param>) : bool {
  var res = true;
  for tx in txs do
    res &= addr = tx.tp_from
  done;
  return res
}

entry transfer_gasless (batch : list<gasless_param>) {
  no transfer
  require { fa2_r3 : is_not_paused() }
  effect {
    for b in batch do
      const txs = b.transfer_params;
      const pk  = b.user_pk;
      const sig = b.user_sig;
      const pkh_signer = key_to_address(pk);
      do_require(check_owner(pkh_signer, txs), SIGNER_NOT_FROM);
      transfer 0tz to permits
        call check<key * signature * bytes>((pk, sig, blake2b(pack(txs))));
      transfer 0tz to entry self.do_transfer(txs);
    done
  }
}

entry %transfer (txs : list<transfer_param>) {
  no transfer
  require { fa2_r4 : is_not_paused() }
  effect {
    if not check_operator(txs) then begin
      match get_from(txs) with
      | some(%from) ->
        transfer 0tz to permits
          call consume<address * bytes * string>((%from, blake2b(pack(txs)), FA2_NOT_OPERATOR))
      | none -> ()
      end
    end;

    transfer 0tz to entry self.do_transfer(txs);
  }
}

variable next_token_id : nat = 1

entry mint (
  first_owner : address, 
  tmd: map<string, bytes>,
  creator_rate : rational,
  marketplace_rate : rational,
  minter_rate : rational,
  token_creator : address
  //add tidemark duration
  //add grace period
  ) {
  no transfer
  called by owner
  require { fa2_r5: is_not_paused() }
  effect {

    ledger.add({ 
      l_token_id = next_token_id; 
      l_token_owner = first_owner;
      l_creator_rate = creator_rate; 
      l_marketplace_rate = marketplace_rate;
      l_minter_rate = minter_rate;
      l_token_creator = token_creator
      });
    
    bid_history.add({
       bh_asset_id = next_token_id;
       bh_token_id = next_token_id
        });

    token_metadata.add_update(next_token_id, {
      token_id   = next_token_id;
      token_info = tmd
    });
    next_token_id := next_token_id + 1
  }
}

entry burn(tid : nat) {
  no transfer
  constant {
    token_owner ?is ledger[tid]?.l_token_owner otherwise FA2_TOKEN_UNDEFINED;
  }
  require {
    fa2_r6: is_not_paused();
    fa2_r7: token_owner = caller otherwise FA2_NOT_OWNER
  }
  effect {
    ledger.remove(tid);
    token_metadata.remove(tid);
  }
}
 
entry make_offer(
  mo_token_id : nat,
  mo_marketplace: address,
  mo_bid: tez,
  ) {
    require {
      tm_r1: mo_bid = transferred otherwise "bid did not equal transferred";
      tm_r2: mo_bid > 0tz otherwise "bid must be greater than 0";
      tm_r3: mo_bid > ledger[mo_token_id].l_bid otherwise "incoming bid must be greater than current bid";
      tm_r4: ledger[mo_token_id].l_token_owner <> caller otherwise "cannot make offer on your own token";
     // tm_r5: Auction must not have concluded
     // tm_r6: mo_marketplace must hold a marketplace token
     // tm_r6: 
     } 

     effect {

      const last_bid = ledger[mo_token_id].l_bid;
      const last_bidder = ledger[mo_token_id].l_bidder;
      const last_marketplace = ledger[mo_token_id].l_marketplace;
      const creator_rate = ledger[mo_token_id].l_creator_rate;
      const minter_rate = ledger[mo_token_id].l_minter_rate;
      //If there was a past bid...
      if last_bid > 0tz then begin
        //...pay back the last bidder...
        transfer last_bid to last_bidder;
        //...and add the bid to the bid history.
        bid_history[mo_token_id].bh_bid_records.prepend({
          br_bid = last_bid;
          br_bidder = last_bidder;
          br_marketplace = last_marketplace
        });
      end;
    //if the tidemark has been passed, then fees are due the creator and minter
    if (transferred > tidemark) then begin
      tidemark := transferred;
      const increase = mo_bid - last_bid;
      const creator_fee = creator_rate * increase;
      const minter_fee = minter_rate * increase;
      transfer creator_fee to ledger[mo_token_id].l_token_creator;
      transfer minter_fee to minter;
    end;
    // Update the token's bid and bidder
    ledger[mo_token_id].l_bid := mo_bid;
    ledger[mo_token_id].l_bidder := caller;
    ledger[mo_token_id].l_marketplace := mo_marketplace;
     }
  }

/* GETTERS ----------------------------------------------------------------- */

record balance_of_request {
  bo_owner : address;
  btoken_id : nat;
} as ((owner, token_id))

record balance_of_response {
  request : balance_of_request;
  balance_ : nat;
} as ((request, balance))
 
function get_balance(br : balance_of_request) : nat {
  const token ?= ledger[br.btoken_id] : FA2_TOKEN_UNDEFINED;
  return (token.l_token_owner = br.bo_owner ? 1 : 0)
}

getter balance_of (requests : list<balance_of_request>) : list<balance_of_response> {
  return map(requests, br -> {
    request = br;
    balance_ = get_balance(br)
  })
}

/* VIEWS ------------------------------------------------------------------- */


/* TZIP-017 One-step  ------------------------------------------------------ */

entry permit_transfer (txs : list<transfer_param>, permit : option<key * signature>) {
  no transfer
  require { fa2_r9 : is_not_paused() }
  effect {
    match permit with
    | some(p) -> begin
        const pk = p[0];
        const sig = p[1];
        const pkh_signer = key_to_address(pk);
        do_require(check_owner(pkh_signer, txs), SIGNER_NOT_FROM);
        transfer 0tz to permits
            call check<key * signature * bytes>((pk, sig, blake2b(pack(txs))));
        transfer 0tz to entry self.do_transfer(txs);
    end
    | none -> begin
      if not check_operator(txs) then begin
        match get_from(txs) with
        | some(%from) ->
          transfer 0tz to permits
            call consume<address * bytes * string>((%from, blake2b(pack(txs)), FA2_NOT_OPERATOR))
        | none -> ()
        end
      end;

      transfer 0tz to entry self.do_transfer(txs);
    end
    end
  }
}