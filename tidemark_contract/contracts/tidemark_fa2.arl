archetype tidemark_fa2(contract_owner : address, permits : address, minter : address) with metadata ""

/* OWNERSHIP TRANSFER ------------------------------------------------------- */

variable owner_candidate : option<address> = none
variable null_address: address = KT18amZmM5W7qDWVt2pH6uj7sCEd3kbzLrHT
variable owner_one_address: address = tz1UibLhnQeRa3LYNaa2SwLgfXpVRXGzG8g8

entry declare_ownership(candidate : address) {
  no transfer
  called by contract_owner
  effect {
    owner_candidate := some(candidate);
  }
}

entry claim_ownership() {
  no transfer
  require {
    ownership_r1: (owner_candidate ? the = caller : false) otherwise "INVALID_CALLER"
  }
  effect {
    contract_owner := caller;
    owner_candidate := none
  }
}

/*  PAUSABLE ----------------------------------------------------------------- */

variable paused : bool = false

function is_not_paused() : bool {
  do_fail_if(paused, "CONTRACT_PAUSED");
  return true
}

entry pause() {
  no transfer
  called by contract_owner
  require {
    pausable_r1: is_not_paused()
  }
  effect {
    paused := true
  }
}

entry unpause() {
  no transfer
  called by contract_owner
  require {
    pausable_r2: paused otherwise "CONTRACT_NOT_PAUSED"
  }
  effect {
    paused := false
  }
}

/* METADATA ---------------------------------------------------------------- */

entry set_metadata(k: string, d : option<bytes>) {
  no transfer
  called by contract_owner
  require { md_r1 : is_not_paused() }
  effect {
    metadata.update(k, d)
  }
}

/* TOKEN METADATA ------------------------------------------------------------ */

asset token_metadata to big_map {
  ftoken_metadata : nat;
  token_id        : nat;
  token_info      : map<string, bytes>;
}

entry set_token_metadata (tid : nat, tdata: map<string, bytes>) {
  no transfer
  called by contract_owner
  require { tmd_r1: is_not_paused() }
  effect {
    token_metadata.add_update(tid, { token_id = tid; token_info = tdata });
  }
}

/* PERMITS ----------------------------------------------------------------- */

entry set_permits(p : address) {
  no transfer
  called by contract_owner
  require { p_r1 : is_not_paused() }
  effect {
    permits := p
  }
}

/* ERRORS ----------------------------------------------------------------- */

constant FA2_INSUFFICIENT_BALANCE : string = "FA2_INSUFFICIENT_BALANCE"
constant FA2_INVALID_AMOUNT       : string = "FA2_INVALID_AMOUNT"
constant FA2_NOT_OPERATOR         : string = "FA2_NOT_OPERATOR"
constant FA2_NOT_OWNER            : string = "FA2_NOT_OWNER"
constant FA2_TOKEN_UNDEFINED      : string = "FA2_TOKEN_UNDEFINED"
constant SIGNER_NOT_FROM          : string = "SIGNER_NOT_FROM"

/* PARAMETERS ------------------------------------------------------------- */

record transfer_destination {
  to_dest           : address;
  token_id_dest     : nat;
  token_amount_dest : nat
} as ((%to_, (token_id, amount)))

record transfer_param {
  tp_from : address;
  tp_txs  : list<transfer_destination>;
} as ((%from_, %txs))

/* STORAGE ---------------------------------------------------------------- */

enum sale_cycle_state =
| tidemark_auction
| english_auction
| grace_period
| unclaimed

variable tidemark : tez = 0tz

asset bid_asset identified by bid_id {
  bid_id: string;
  bid_number: nat = 0;
  bid: tez = 0tz;
  bidder: address = contract_owner;
  marketplace: address = contract_owner;
}

asset ownership_asset {
  ownership_id: string;
  owner_number: nat;
  date_purchased: date;
  owner: address;
  purchase_price: tez;
  time_held: duration;
  burden_paid: tez;
}
//owr = "ownership working record"
// record owr {
//   owr_previous_price : tez = 0tz;
//   owr_purchase_price : tez;
//   owr_time_held : duration;
// }


record band {
  lower: tez;
  upper: tez;
}

asset ledger identified by l_token_id to big_map {
  l_token_id   : nat;
  l_token_creator : address;
  l_token_owner     : address;
  l_token_balance : tez = 0tz;
  l_tidemark: tez = 0tz;
  l_creator_rate: rational;
  l_creator_fee_paid_since_last_sale: tez = 0tz;
  l_marketplace_rate: rational;
  l_minter_rate: rational;
  l_sale_cycle_state: sale_cycle_state = tidemark_auction;
  l_tidemark_duration: duration = 1w;
  l_grace_period_duration: duration = 1d;
  l_bid_number: nat = 0;
  l_bids: partition<bid_asset>;
  l_owner_number: nat = 0;
  l_ownership: partition<ownership_asset>;
}

asset operator identified by oaddr otoken oowner to big_map {
  oaddr       : address;
  otoken      : nat;
  oowner      : address;
}

asset operator_for_all identified by fa_oaddr fa_oowner to big_map {
  fa_oaddr    : address;
  fa_oowner   : address;
}

/* FUNCTIONS --------------------------------------------------------------- */

function get_from(txs : list<transfer_param>) : option<address> {
  match txs with
  | hd::tl -> begin
    const %from = hd.tp_from;
    for tx in tl do
      do_require(%from = tx.tp_from, FA2_NOT_OPERATOR)
    done;
    return some(%from)
  end
  | [] -> return none
  end
}

function check_operator(txs : list<transfer_param>) : bool {
  var res = true;
  for tx in txs do
    const %from = tx.tp_from;
    const tds = tx.tp_txs;
    for td in tds do begin
      res &=
        if caller <> %from then
          (operator.contains((caller, td.token_id_dest, %from)) or
           operator_for_all.contains((caller, %from)))
        else
          true;
    end
    done
  done;
  return res
}

//Sell utilites:
function get_band_total(m: map<string, duration>) : duration {
  var total: duration = 0s;
  for (k, v) in m do
    total += v;
  done;
  return total
}

function get_all_band_totals_map(all_bands_duration_map: map<band, map<string, duration>>) : map<band, duration> {
  var total_map: map<band, duration> = [];
  for (k, v) in all_bands_duration_map do
    total_map.put(k, get_band_total(v));
  done;
  return total_map
}

function convert_one_band_duration_map_to_one_band_fair_burden_map(burden_to_split : tez, one_band_duration_map: map<string, duration>, total: duration) : map<string, tez> {
  var one_band_fair_burden_map: map<string, tez> = [];
  for (k, v) in one_band_duration_map do
    const proportion = v / total;
    const fair_burden = proportion * burden_to_split;
    one_band_fair_burden_map.put(k, fair_burden);
  done;
  return one_band_fair_burden_map
}

function convert_all_bands_duration_map_to_all_bands_fair_burden_map(all_bands_duration_map: map<band, map<string, duration>>, totals: map<band, duration>, creator_rate: rational) : map<band, map<string, tez>> {
  var all_bands_fair_burden_map: map<band, map<string, tez>> = [];
  for (band_record, v) in all_bands_duration_map do
    const this_band_total_duration ?= totals[band_record];
    const this_bands_durations ?= all_bands_duration_map[band_record];
    const this_bands_burden = creator_rate * (band_record.upper - band_record.lower);
    const this_bands_fair_burdens: map<string, tez> = 
      convert_one_band_duration_map_to_one_band_fair_burden_map(this_bands_burden, this_bands_durations, this_band_total_duration);
    all_bands_fair_burden_map.put(band_record, this_bands_fair_burdens);
  done;
  return all_bands_fair_burden_map
}

function get_all_bands_fair_burden_map(all_bands_duration_map: map<band, map<string, duration>>, creator_rate: rational) : map<band, map<string, tez>> {
  const totals: map<band, duration> = get_all_band_totals_map(all_bands_duration_map);
  return convert_all_bands_duration_map_to_all_bands_fair_burden_map(all_bands_duration_map, totals, creator_rate)
}

function get_fair_burden_by_id_map(all_bands_fair_burden_map: map<band, map<string, tez>>): map<string, tez> {
  var fair_burden_by_id_map: map<string, tez> = [];
  for (band_record, v) in all_bands_fair_burden_map do
    for (id, burden) in v do
      match fair_burden_by_id_map[id] with
      | some(t) -> fair_burden_by_id_map.put(id, t + burden)
      | none -> fair_burden_by_id_map.put(id, burden)
      end;
    done;
  done;
  return fair_burden_by_id_map
}

// THIS FAILS AT THE MOMENT BECAUSE this_burden_paid IS ALWAYS ZERO
function get_refund_due_map(fair_burden_by_id_map: map<string, tez>) : map<string, tez> {
  var refund_due_map: map<string, tez> = [];
  for (id, fair_burden) in fair_burden_by_id_map do
    const this_burden_paid = ownership_asset[id].burden_paid;
    const diff = this_burden_paid - fair_burden;
    const this_refund_due = diff >= 0tz ? diff : 0tz;
    refund_due_map.put(id, this_refund_due)
  done;
  return refund_due_map
}

/* ENTRYPOINTS ------------------------------------------------------------- */

record operator_param {
  opp_owner    : address;
  opp_operator : address;
  opp_token_id : nat
} as ((contract_owner, (operator, token_id)))

enum update_op =
| add_operator<operator_param>
| remove_operator<operator_param>

entry update_operators (upl : list<update_op>) {
  no transfer
  require { fa2_r1 : is_not_paused() }
  effect {
    for up in upl do
      match up with
      | add_operator(param) -> (* add *)
        do_require(param.opp_owner = caller , FA2_NOT_OWNER);
        operator.put({param.opp_operator; param.opp_token_id; param.opp_owner})
      | remove_operator(param) -> (* remove *)
        do_require(param.opp_owner = caller , FA2_NOT_OWNER);
        operator.remove((param.opp_operator, param.opp_token_id, param.opp_owner))
      end;
    done;
  }
}

enum update_for_all_op =
| add_for_all<address>
| remove_for_all<address>

entry update_operators_for_all (upl : list<update_for_all_op>) {
  no transfer
  require { fa2_r2 : is_not_paused() }
  effect {
    for up in upl do
      match up with
      | add_for_all(op) ->
          operator_for_all.put({ op; caller })
      | remove_for_all(op) ->
          operator_for_all.remove((op, caller))
      end;
    done;
  }
}

entry do_transfer(txs : list<transfer_param>) {
  no transfer
  called by self_address
  effect {
    for tx in txs do
      const %from = tx.tp_from;
      const tds   = tx.tp_txs;
      for td in tds do begin
        const tokenid = td.token_id_dest;
        const towner ?= ledger[tokenid]?.l_token_owner : FA2_TOKEN_UNDEFINED;
        if td.token_amount_dest > 0
        then begin
          do_require(towner = %from and td.token_amount_dest = 1, FA2_INSUFFICIENT_BALANCE);
          ledger.update(tokenid, { l_token_owner = td.to_dest })
        end
      end done
    done
  }
}

record gasless_param {
  transfer_params : list<transfer_param>;
  user_pk         : key;
  user_sig        : signature
}

function check_owner(addr : address, txs : list<transfer_param>) : bool {
  var res = true;
  for tx in txs do
    res &= addr = tx.tp_from
  done;
  return res
}

entry transfer_gasless (batch : list<gasless_param>) {
  no transfer
  require { fa2_r3 : is_not_paused() }
  effect {
    for b in batch do
      const txs = b.transfer_params;
      const pk  = b.user_pk;
      const sig = b.user_sig;
      const pkh_signer = key_to_address(pk);
      do_require(check_owner(pkh_signer, txs), SIGNER_NOT_FROM);
      transfer 0tz to permits
        call check<key * signature * bytes>((pk, sig, blake2b(pack(txs))));
      transfer 0tz to entry self.do_transfer(txs);
    done
  }
}

entry %transfer (txs : list<transfer_param>) {
  no transfer
  require { fa2_r4 : is_not_paused() }
  effect {
    if not check_operator(txs) then begin
      match get_from(txs) with
      | some(%from) ->
        transfer 0tz to permits
          call consume<address * bytes * string>((%from, blake2b(pack(txs)), FA2_NOT_OPERATOR))
      | none -> ()
      end
    end;

    transfer 0tz to entry self.do_transfer(txs);
  }
}
variable next_token_id : nat = 1




function make_bid_id(ntid: nat, bid_num: nat) : string {
  return ("t" + nat_to_string(ntid) + "|b" + nat_to_string(bid_num))
}

function make_ownership_id(ntid: nat, owner_num: nat) : string {
  return ("t" + nat_to_string(ntid) + "|o" + nat_to_string(owner_num))
}


entry mint (
  tmd: map<string, bytes>,
  creator_rate : rational,
  marketplace_rate : rational,
  minter_rate : rational
  //add tidemark duration
  //add grace period
  ) {
  no transfer
  called by contract_owner
  require { fa2_r5: is_not_paused() }
  effect {


    ledger.add({ 
      l_token_id = next_token_id; 
      l_token_owner = caller;
      l_creator_rate = creator_rate; 
      l_marketplace_rate = marketplace_rate;
      l_minter_rate = minter_rate;
      l_token_creator = caller;
      l_bids = [];
      l_ownership = []
      });

      //Add the dummy first bid (bid 0)
      ledger[next_token_id].l_bids.add({make_bid_id(next_token_id, 0); 0; 0tz; contract_owner; contract_owner});
    
      //Add creator as dummy first owner (owner 0)
      ledger[next_token_id].l_ownership.add({
                ownership_id = make_ownership_id(next_token_id, 0);
                owner_number = 0;
                date_purchased = now;
                owner = caller;
                purchase_price = 0tz;
                time_held = 0s;
                burden_paid = 0tz
              });
    
          

    token_metadata.add_update(next_token_id, {
      token_id   = next_token_id;
      token_info = tmd
        });


    //     });
    next_token_id := next_token_id + 1
  }
}

entry burn(tid : nat) {
  no transfer
  constant {
    token_owner ?is ledger[tid]?.l_token_owner otherwise FA2_TOKEN_UNDEFINED;
  }
  require {
    fa2_r6: is_not_paused();
    fa2_r7: token_owner = caller otherwise FA2_NOT_OWNER
  }
  effect {
    ledger.remove(tid);
    token_metadata.remove(tid);
  }
}
 
entry make_offer(
  mo_token_id : nat,
  mo_marketplace: address,
  mo_bid: tez,
  ) {
    require { 
      tm_r1: mo_bid = transferred otherwise "bid did not equal transferred";
      tm_r2: mo_bid > 0tz otherwise "bid must be greater than 0";
      tm_r3: ledger[mo_token_id].l_token_owner <> caller otherwise "cannot make offer on your own token";
     // tm_r4: Auction must not have concluded
     // tm_r5: mo_marketplace must hold a marketplace token
       tm_r6: is_not_paused();
     } 

     effect {
      const token_ledger ?= ledger[mo_token_id];
      const last_bid_number = token_ledger.l_bid_number;
      const last_bid_asset_id = make_bid_id(mo_token_id, last_bid_number);
      // if mo_bid = 5tz then begin
      //   fail(("last_bid_asset_id", last_bid_asset_id))
      // end;
      const last_bid_asset_value ?= bid_asset[last_bid_asset_id];

      const last_bid = last_bid_asset_value.bid;
      const last_bidder = last_bid_asset_value.bidder;
      const creator_rate = ledger[mo_token_id].l_creator_rate;
      const minter_rate = ledger[mo_token_id].l_minter_rate;

      do_require(mo_bid > last_bid, "incoming bid must be greater than current bid");
      
    //track the token balance locally...
     var mo_token_balance_tracker = ledger[mo_token_id].l_token_balance;
      mo_token_balance_tracker += mo_bid;


      //If there was a past bid...
      if last_bid > 0tz then begin
        //...pay back the last bidder...
        transfer last_bid to last_bidder;
        //...and update the token balance locally.
        mo_token_balance_tracker -= last_bid;
      end;

    //if the tidemark has been passed, then update the tidemark...
    if (transferred > tidemark) then begin
      tidemark := transferred;
      const increase = mo_bid - last_bid;
      const creator_fee = creator_rate * increase;
      const minter_fee = minter_rate * increase;
      //...and pay the creator and minter their fees.
      transfer creator_fee to ledger[mo_token_id].l_token_creator;
      mo_token_balance_tracker -= creator_fee;
      ledger[mo_token_id].l_creator_fee_paid_since_last_sale += creator_fee;
      transfer minter_fee to minter;
      mo_token_balance_tracker -= minter_fee;
    end;

    //update the bid number locally
    const new_bid_number: nat = last_bid_number + 1;
    //update the bid number in storage
    ledger[mo_token_id].l_bid_number := new_bid_number;
    // Create local variable for current bid record


    // Add current bid to bid history
    // TODO need a function for deleting bid records when they exceed a certain number, eg 20.

    const new_bid_id = make_bid_id(mo_token_id, new_bid_number);
    ledger[mo_token_id].l_bids.add({
      bid_id = new_bid_id;
      bid = mo_bid;
      bidder = caller;
      marketplace = mo_marketplace
      });
    
    //update the token balance in storage
    ledger[mo_token_id].l_token_balance := mo_token_balance_tracker;
     }
  }
variable all_bands_duration_map_out : map<band, map<string, duration>> = []
variable total_time_held_map_out : map<band, duration> = []
variable all_bands_proportion_map_out : map<band, map<string, rational>> = []
variable all_bands_fair_burden_map_out : map<band, map<string, tez>> = []
variable fair_burden_by_id_map_out : map<string, tez> = []
variable refund_due_out : map<string, tez> = []

entry sell(s_token_id : nat) {
  effect {
      const winning_bid_number = ledger[s_token_id].l_bid_number;
      const last_bid_asset_id = make_bid_id(s_token_id, winning_bid_number);
      const last_bid_asset_value ?= bid_asset[last_bid_asset_id];
      const winning_bid = last_bid_asset_value.bid;
      const winning_bidder = last_bid_asset_value.bidder;
      const creator_rate = ledger[s_token_id].l_creator_rate;
      const marketplace_rate = ledger[s_token_id].l_marketplace_rate;
      const marketplace_fee = marketplace_rate * winning_bid;
      const seller = ledger[s_token_id].l_token_owner;

      //Get seller owner number
      const owner_number_before_sale = ledger[s_token_id].l_owner_number;
    
      // updte owner_number on token ledger asset value
      const owner_number_after_sale = owner_number_before_sale + 1;
      ledger[s_token_id].l_owner_number := owner_number_after_sale;
      
      // Get seller ownership id into local variable
      const seller_ownership_id = make_ownership_id(s_token_id, owner_number_before_sale);


      //REQUIREMENTS:
      do_require(winning_bid_number > 0, "no bids have been made on this token");
      do_require(caller = ledger[s_token_id].l_token_owner or caller = self_address, "only owner or the contract itself may call the sell entrypoint");

      //track the token balance locally...
      var s_token_balance_tracker = ledger[s_token_id].l_token_balance; 

      // Get asset view of the bids above 0:
      const bids_above_zero = ledger[s_token_id].l_bids.select(the.bid > 0tz);
     
      // Calculate what each marketplace is due
      // TODO: Update this to use exponential split with global constant
      const splitMap: map<nat, tez> = evenSplit(marketplace_fee, bids_above_zero);

      // Pay each marketplace their share
      for b in bids_above_zero do
        // The first bid is a dummy bid with a bid of 0 and a marketplace of null_address.
        // Attempt to pay to this address will fail with an ENTRY_NOT_FOUND error, so we skip it.
        const this_bid_number = bid_asset[b].bid_number;
        const this_marketplace = bid_asset[b].marketplace;
        const split ?= splitMap[this_bid_number] : "DEV_ERR: const split ?= splitMap[n]";
        transfer split to this_marketplace;
        s_token_balance_tracker -= split;
      done;

      // reset bid_history
      ledger[s_token_id].l_bids.remove_all();
      ledger[s_token_id].l_bids.add({make_bid_id(s_token_id, 0); 0; 0tz; contract_owner; contract_owner});
      
      //reset bid_number
      ledger[s_token_id].l_bid_number := 0;

      // Update seller's burden_paid and reset l_creator_fee_paid_since_last_sale
      const seller_burden_paid = ledger[s_token_id].l_creator_fee_paid_since_last_sale;
      ledger[s_token_id].l_creator_fee_paid_since_last_sale := 0tz;
      ownership_asset[seller_ownership_id].burden_paid += seller_burden_paid;
      // Pay a fair share of royalties back to previous owners of the contract
        // get an asset view of post ownerships sorted from lowest to highest price

        //Do I need to sort these by price? Will they be sorted automatically by "set"?
        // const token_oh_sorted = token_oh.sort(purchase_price);

        // var working_map: map<string, owr> = [];

        // for id in token_oh_sorted do
        //   working_map.put(
        //     id, {
        //       owr_purchase_price = ownership_asset[id].purchase_price;
        //       owr_time_held = ownership_asset[id].time_held
        //   })
        // done;

        // const purchased_price_set = get_purchased_price_set(working_map);


      //Update time held for previous owner in their ownership history record:
        //Get date of purchase for previous owner...
      const dop_previous_owner = ownership_asset[seller_ownership_id].date_purchased;
        //... use the date of purchase to calculate time held ...     
      const time_held_previous_owner = now - dop_previous_owner;
        //... update time held in the seller's ownership history asset value: 
      ownership_asset.update(seller_ownership_id, {
        time_held := time_held_previous_owner
        }); 
        
        //Get the ownership history specific to this token:
        const token_oh = ledger[s_token_id].l_ownership.select(purchase_price > 0tz);
        const sorted_token_oh = token_oh.sort(purchase_price);

        //initialise map of bands to times held by various owners in that band
        var all_bands_duration_map: map<band, map<string, duration>> = [];
        // all_bands_duration_map: map<band, map<ownership_asset_id, time_held>>
        var last_price = 0tz;
        for id in sorted_token_oh do
          //We've got a view of assets that are sorted by purchase price, each with a unique id
          //However, some may have the same price, so we need to group those in the same bands,
          // which will mean treating them differently to the other cases.
        const this_price = ownership_asset[id].purchase_price;
        const this_band: band = {
          lower = last_price;
          upper = this_price
        };
        //If this is the first of this price:
        if last_price <> this_price then begin
          //Create a new map for this band
        const empty_duration_map: map<string, duration> = [];
        all_bands_duration_map.put(this_band, empty_duration_map);
        end;
        
        //add the duration tuples to all bands
         for (band_record, duration_map) in all_bands_duration_map do
          const this_time_held = ownership_asset[id].time_held;
          duration_map.put(id, this_time_held);
          all_bands_duration_map.put(band_record, duration_map);

          //Duration map to total_time function - which is fed into a all_bands_duration_map to map of total_times function 
          //Update the total time held in the band, 5s)

         done;
         last_price := this_price;
        done;


        // all_bands_fair_burden_map_out := get_all_bands_fair_burden_map(all_bands_duration_map, creator_rate);
        fair_burden_by_id_map_out := get_fair_burden_by_id_map(get_all_bands_fair_burden_map(all_bands_duration_map, creator_rate));

        refund_due_out := get_refund_due_map(
        get_fair_burden_by_id_map(get_all_bands_fair_burden_map(all_bands_duration_map, creator_rate)));

        // var total_time_held_map: map<band, duration> = get_all_band_totals_map(all_bands_duration_map);

        // band_map_out := all_bands_duration_map;
        // total_time_held_map_out := total_time_held_map;

      

      var fair_burden_map: map<string, tez> = [];

      // for (band_rec, time_held_map) in all_bands_duration_map do
      //   const total_time_held_this_band = band_rec.band_time_held;
      //   for (id, t_h) in time_held_map do 
      //   const proportion_of_time_held = t_h / total_time_held_this_band;
      //   const creator_fee_this_band = creator_rate * (band_rec.upper - band_rec.lower);
      //   const fair_burden_this_band = proportion_of_time_held * creator_fee_this_band;
        

      //   done

      //   //WORKING BACKWARDS, WE JUST WANT A MAP :=> map<string, tez> that gives map<id, fair_burden>
      //   //Then we iterate across this, comparing it to the actual burden paid, and balance the difference.
      // //   const creator_fee_this_band = creator_rate * (k.upper - k.lower);

      // done;

        // owm_out := all_bands_duration_map;

      //Pay seller
      transfer s_token_balance_tracker to seller;
      //Transfer Ownership
      ledger[s_token_id].l_token_owner := winning_bidder;
      //Update token balance locally ...
      s_token_balance_tracker := 0tz;
      //...and in storage
      ledger[s_token_id].l_token_balance := s_token_balance_tracker;
      
 

        //add the new ownership asset value to the ownership collection
      ledger[s_token_id].l_ownership.add({

        ownership_id = make_ownership_id(s_token_id, owner_number_after_sale);
        owner_number = owner_number_after_sale;
        date_purchased = now;
        owner = winning_bidder;
        purchase_price = winning_bid;
        time_held = 0s;
        burden_paid = 0tz
      });

    }
}


// function get_purchased_price_set(m: map<string, owr>) : set<tez> {
//   var price_set : set<tez> = [];
//   for (k, v) in m do
//     price_set.add(ownership_asset[k].purchase_price);
//   done;
//   return price_set
// }



// This evenSplit function needs to be replaced with the exponential split
function evenSplit(feeToSplit: tez, bidView : asset_view<bid_asset> ) : map<nat, tez> {
  var splitMap : map<nat, tez> = [];
  const bids_length = bidView.count();
  const bid_divisor = bids_length;
  for b in bidView do
    const tezDue : tez = feeToSplit div bid_divisor;
    splitMap.update(bid_asset[b].bid_number, some(tezDue));
  done;
  return splitMap
}


//CURRENTLY HARD CODED - ALWAYS RETURNS FALSE
function isAddressContract(ad: address) : bool {
  return false
}



/* GETTERS ----------------------------------------------------------------- */

record balance_of_request {
  bo_owner : address;
  btoken_id : nat;
} as ((owner, token_id))

record balance_of_response {
  request : balance_of_request;
  balance_ : nat;
} as ((request, balance))
 
function get_balance(br : balance_of_request) : nat {
  const token ?= ledger[br.btoken_id] : FA2_TOKEN_UNDEFINED;
  return (token.l_token_owner = br.bo_owner ? 1 : 0)
}

getter balance_of (requests : list<balance_of_request>) : list<balance_of_response> {
  return map(requests, br -> {
    request = br;
    balance_ = get_balance(br)
  })
}

/* VIEWS ------------------------------------------------------------------- */


/* TZIP-017 One-step  ------------------------------------------------------ */

entry permit_transfer (txs : list<transfer_param>, permit : option<key * signature>) {
  no transfer
  require { fa2_r9 : is_not_paused() }
  effect {
    match permit with
    | some(p) -> begin
        const pk = p[0];
        const sig = p[1];
        const pkh_signer = key_to_address(pk);
        do_require(check_owner(pkh_signer, txs), SIGNER_NOT_FROM);
        transfer 0tz to permits
            call check<key * signature * bytes>((pk, sig, blake2b(pack(txs))));
        transfer 0tz to entry self.do_transfer(txs);
    end
    | none -> begin
      if not check_operator(txs) then begin
        match get_from(txs) with
        | some(%from) ->
          transfer 0tz to permits
            call consume<address * bytes * string>((%from, blake2b(pack(txs)), FA2_NOT_OPERATOR))
        | none -> ()
        end
      end;

      transfer 0tz to entry self.do_transfer(txs);
    end
    end
  }
}